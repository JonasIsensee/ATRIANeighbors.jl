# ATRIANeighbors.jl

[![CI](https://github.com/JonasIsensee/ATRIANeighbors.jl/actions/workflows/CI.yml/badge.svg)](https://github.com/JonasIsensee/ATRIANeighbors.jl/actions/workflows/CI.yml)
[![codecov](https://codecov.io/gh/JonasIsensee/ATRIANeighbors.jl/branch/main/graph/badge.svg)](https://codecov.io/gh/JonasIsensee/ATRIANeighbors.jl)

Fast k-nearest neighbor search optimized for low-dimensional manifolds embedded in high-dimensional spaces.

## Overview

ATRIANeighbors.jl implements the ATRIA algorithm (Advanced TRiangle Inequality Algorithm) for efficient nearest neighbor search. Unlike tree-based methods that struggle with high-dimensional spaces (the "curse of dimensionality"), ATRIA exploits the observation that real-world datasets often lie on low-dimensional manifolds with fractal dimension much smaller than the embedding dimension.

**Key features:**

- Performance depends on intrinsic (fractal) dimension rather than embedding dimension
- Supports any metric (not limited to Euclidean distance)
- Allocation-free search for maximum performance
- Exact and approximate search modes
- Optimized for time series analysis and nonlinear dynamics applications

Based on: Merkwirth, Parlitz, and Lauterborn, _Physical Review E_ **62**, 2089 (2000)

## Performance

ATRIA excels on data with low fractal dimension - especially chaotic attractors and time series embeddings where the intrinsic dimension is much smaller than the embedding space.

### Benchmark Results

Performance on Lorenz attractor data (N=50,000 points, D=3, k=10 neighbors, 100 queries):

| Algorithm | Build Time | Query Time | Speedup vs Brute |
| --------- | ---------- | ---------- | ---------------- |
| ATRIA     | 85 ms      | 0.035 ms   | 485x             |
| KDTree    | 38 ms      | 0.052 ms   | 327x             |
| BallTree  | 45 ms      | 0.068 ms   | 250x             |
| Brute     | -          | 17.0 ms    | 1x               |

**ATRIA is 1.5x faster than KDTree** on this low-dimensional attractor (fractal dimension ≈ 2.06).

#### Reproducing the Benchmark

The Lorenz attractor is generated by integrating the classic system:

```julia
# Generate N points from the Lorenz attractor (D×N layout)
function generate_lorenz(N; σ=10.0, ρ=28.0, β=8/3, dt=0.01)
    x, y, z = 1.0, 1.0, 1.0
    points = zeros(3, N)  # 3×N matrix (D×N layout: columns are points)
    for i in 1:N
        # Lorenz equations: dx/dt = σ(y-x), dy/dt = x(ρ-z)-y, dz/dt = xy-βz
        points[1, i] = x
        points[2, i] = y
        points[3, i] = z
        x += dt * σ * (y - x)
        y += dt * (x * (ρ - z) - y)
        z += dt * (x * y - β * z)
    end
    return points
end
```

To run the complete benchmark and reproduce this table:

```bash
# Clone the repository
git clone https://github.com/JonasIsensee/ATRIANeighbors.jl
cd ATRIANeighbors.jl

# Set up benchmark environment (from repository root)
cd benchmark
julia --project=. -e 'using Pkg; Pkg.instantiate(); Pkg.develop(path="..")'

# Run the benchmark
julia --project=. benchmark.jl readme
```

See [`benchmark/README.md`](benchmark/README.md) for the full benchmark suite documentation.

### Scaling with Fractal Dimension

The algorithm's efficiency depends primarily on the fractal/information dimension D₁ of the data:

| D₁  | Relative Cost | Typical Data Type                  |
| --- | ------------- | ---------------------------------- |
| 2   | 0.001         | Lorenz attractor                   |
| 4   | 0.003         | Rössler system                     |
| 6   | 0.015         | Clustered data                     |
| 10  | 0.08          | Moderately structured              |
| 15  | 0.25          | High-dimensional, sparse structure |

_Values show fraction of distance calculations relative to brute force (N=200,000)_

## Installation

```julia
using Pkg
Pkg.add("ATRIANeighbors")
```

Or install from source:

```julia
Pkg.add(url="https://github.com/JonasIsensee/ATRIANeighbors.jl")
```

## Quick Start

### Basic k-NN Search

```julia
using ATRIANeighbors

# Create data (D×N layout: each column is a point)
# Matches NearestNeighbors.jl convention for cache-efficient access
data = randn(20, 10000)  # 10000 points in 20D

# Build ATRIA tree (simple: directly from matrix)
tree = ATRIATree(data)

# Find 10 nearest neighbors
query = randn(20)
neighbors = knn(tree, query, k=10)
indices = [n.index for n in neighbors]
distances = [n.distance for n in neighbors]
```

### Batch Queries

```julia
# Pass a matrix and knn handles batching automatically
# D×N layout: 1000 queries in 20D
queries = randn(20, 1000)
results = knn(tree, queries, k=10)            # sequential
results = knn(tree, queries, k=10, parallel=true)  # multi-threaded
```

### Time Series Analysis

```julia
# Time-delay embedding (memory efficient)
signal = randn(50000)
ps = EmbeddedTimeSeries(signal, dim=7, delay=5)
tree = ATRIATree(ps, min_points=64)

# Find neighbors of point 1000 in embedded space
query = getpoint(ps, 1000)
neighbors = knn(tree, query, k=10)
```

### Range Search

```julia
# Find all neighbors within radius
neighbors = range_search(tree, query, radius=0.5)
# Extract indices and distances from Neighbor objects
indices = [n.index for n in neighbors]
distances = [n.distance for n in neighbors]

# Count neighbors (faster than range search)
count = count_range(tree, query, radius=0.5)
```

### Other Metrics

Metrics are not exported but accessible via module-qualified names:

```julia
using ATRIANeighbors: MaximumMetric, ExponentiallyWeightedEuclidean

# Maximum (Chebyshev) metric
tree = ATRIATree(data, metric=MaximumMetric())

# Exponentially weighted Euclidean (decay factor 0 < λ ≤ 1)
tree = ATRIATree(data, metric=ExponentiallyWeightedEuclidean(0.9))
```

## Algorithm Details

ATRIA builds a hierarchical binary cluster tree during preprocessing:

1. Recursively partition points into clusters with two centers
2. Store precomputed distances to cluster centers (permutation table)
3. Compute bounds (radius Rₘₐₓ and minimum gap gₘᵢₙ) for each cluster

During search, a priority queue enables best-first traversal:

- Triangle inequality provides lower bounds on distances to cluster contents
- Clusters provably too far from query are pruned without examining their points
- Partial distance calculation terminates early when distances exceed current k-th neighbor

**Complexity:** O(N log N) preprocessing, O(N^(D₁/Dₛ)) queries for fractal dimension D₁ << embedding dimension Dₛ

## When to Use ATRIA

**Ideal for:**

- **Chaotic attractors** with low fractal dimension (Lorenz, Rössler, Hénon, etc.)
- **Time series analysis** with time-delay embeddings
- **Nonlinear dynamics**: correlation dimension, Lyapunov exponents, prediction
- Data on low-dimensional manifolds (even if embedded in high-D space)
- Applications requiring **any metric** (not just Euclidean)

**Consider alternatives for:**

- Uniformly distributed data (no structure to exploit)
- Very small datasets (N < 1000) where preprocessing overhead dominates
- Low-dimensional data (D < 5) with L∞ metric (KDTree excels here)

## API Reference

### Data Layout

ATRIANeighbors uses **D×N layout** (each column is a point) matching NearestNeighbors.jl convention.
This provides contiguous memory access for cache-efficient distance computation.

### Tree Construction

- `ATRIATree(data; metric=EuclideanMetric(), min_points=64)` - Build tree from D×N matrix
- `ATRIATree(ps::AbstractPointSet; min_points=64)` - Build tree from point set
- `EmbeddedTimeSeries(signal; dim, delay=1)` - Time-delay embedding point set

### Search

- `knn(tree, query; k=1)` - Find k nearest neighbors (single query vector)
- `knn(tree, queries; k=1, parallel=false)` - Batch search (D×N query matrix)
- `range_search(tree, query; radius)` - All neighbors within radius
- `count_range(tree, query; radius)` - Count neighbors within radius

### Allocation-Free Batch Queries

- `SearchContext(tree, k)` - Pre-allocated context for batch queries

```julia
ctx = SearchContext(tree, k)
for i in 1:n_queries
    neighbors = knn(tree, queries[i], k=k, ctx=ctx)  # 1 allocation per query
end
```

### Metrics (not exported, use via `using ATRIANeighbors: ...`)

- `EuclideanMetric()` - L₂ distance (default)
- `MaximumMetric()` - L∞ (Chebyshev) distance
- `ExponentiallyWeightedEuclidean(lambda)` - Exponentially weighted L₂ (0 < λ ≤ 1)

## Contributing

Contributions welcome! Areas of interest:

- Additional distance metrics
- Approximate search with error bounds
- Parallel query processing
- Benchmark comparisons with other libraries

## Citation

If you use this software in academic work, please cite the original paper:

```bibtex
@article{merkwirth2000fast,
  title={Fast nearest-neighbor searching for nonlinear signal processing},
  author={Merkwirth, Christian and Parlitz, Ulrich and Lauterborn, Werner},
  journal={Physical Review E},
  volume={62},
  number={2},
  pages={2089},
  year={2000},
  publisher={APS}
}
```

## License

MIT License - see LICENSE file for details.
